"use strict";
var SHA1 = require('jshashes').SHA1;
var stream = require('stream');
var File = require('vinyl');
var sha1 = new SHA1();
function gulpGenManifest(manifest) {
    var out = new stream.Readable({ read: function () { }, objectMode: true });
    (new ManifestWriter(new GulpSourceResolver()))
        .generate(manifest)
        .then(function (contents) {
        out.push(new File({
            cwd: '/',
            base: '/',
            path: '/manifest.appcache',
            contents: new Buffer(contents)
        }));
        out.push(null);
    });
    return out;
}
exports.gulpGenManifest = gulpGenManifest;
var ManifestWriter = (function () {
    function ManifestWriter(resolver) {
        this.resolver = resolver;
    }
    ManifestWriter.prototype.writeGroup = function (group) {
        return this
            .resolver
            .resolve(group.sources)
            .then(function (map) {
            var lines = [];
            lines.push("# sw.group: " + group.name);
            Object.keys(map).forEach(function (path) {
                var hash = sha1.hex(map[path]);
                lines.push("# sw.hash: " + hash);
                lines.push(path);
            });
            return lines;
        });
    };
    ManifestWriter.prototype.generate = function (manifest) {
        var _this = this;
        var lines = [
            'CACHE MANIFEST',
            'CACHE:'
        ];
        var linesPerGroup = Promise.all(manifest.group.map(function (group) { return _this.writeGroup(group); }));
        return linesPerGroup.then(function (groups) {
            groups.forEach(function (group) { return lines.push.apply(lines, group); });
        }).then(function () {
            lines.push.apply(lines, [
                'NETWORK:',
                '*',
                ''
            ]);
            return lines.join('\n');
        });
    };
    return ManifestWriter;
}());
exports.ManifestWriter = ManifestWriter;
var GulpSourceResolver = (function () {
    function GulpSourceResolver() {
    }
    GulpSourceResolver.prototype.resolve = function (sources) {
        return new Promise(function (resolve, reject) {
            var map = {};
            sources.on('data', function (file) {
                map[("/" + file.relative)] = file.contents.toString();
            });
            sources.on('end', function () { return resolve(map); });
        });
    };
    return GulpSourceResolver;
}());
exports.GulpSourceResolver = GulpSourceResolver;
